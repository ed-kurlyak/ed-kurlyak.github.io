<!DOCTYPE html>
<html>
<head>
	<title>Игра Тетрис на С++ WinAPI Visual Studio 2019</title>

	<meta name="DESCRIPTION" content="Игра Тетрис на С++ WinAPI Visual Studio 2019">
	<meta name="KEYWORDS" content="Игра Тетрис на С++ WinAPI Visual Studio 2019">

<style type="text/css">
body {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #000;
	color: #ffffff;
}

pre {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #ffffaa;
	color: #000;
	width: max-content;
	min-width: 100%;

}

div.my_selected {
	width: 100%;
	background-color: #ffff55;
	position: relative;
}

a:link, a:visited { color: #aaaaaa; text-decoration: none; font-weight: normal;} 
a:active, a:hover { color: #aaaaaa; text-decoration: underline;}

p {
	text-align: justify;
	margin-right: 20px;
}

</style>	
</head>
<body>

<h3>
Игра Тетрис на С++ WinAPI Visual Studio 2019
</h3>

<img src="./tetris.jpg" width=250>

<p>
Пример исходного кода можно загрузить <a href="./TETRIS.rar">ЗДЕСЬ</a>. Пример разработан на С++ WinAPI Visual Studio 2019. Код хорошо прокомментирован.
</p>

<p>
На игровом поле Тетрис находятся фигуроки, которые называються <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%82%D1%80%D0%B0%D0%BC%D0%B8%D0%BD%D0%BE">Тетрамино</a> (как сказано в Википедии).
</p>

<p>
Тетрамино из игры Тетрис представлены на рисунке ниже.
</p>

<img src="./tetramino.jpg" width="500px">

<p>
Всего в игре Тетрис может быть 7 таких фигурок.
</p>

<p>
Каждая фигурка Тетрамино состоит из 4 квадратов.
</p>

<p>
Самая большая фигрука Тетрамино по высоте занимает 4 квадрата, и самая большая фигурка по ширине занимает 2 квадрата. Поэтому очень удобно хранить описание одного Тетрамино так как представлено на рисунке ниже.
</p>

<img src="./tetramino2.jpg" width="500px">

<p>
Для хранения всех фигурок тетрамино можно задать массив 7х4 где 7 это количество Тетрамино в Тетрисе, а 4 это максимальное количество квадратов из которых состоит одно Тетрамино.
</p>

<p>
Причем не важно в каком порядке следуют закрашенные квадраты на рисунке выше, важен лишь сам факт- закрашен квадрат или нет. Поэтому для первой фигуры к квадратами (3, 5, 4, 6) в соответствие можно поставить как набор (5, 3, 4, 6) так и (3, 5, 6, 4).
</p>

<p>
Игровое поле можно представить в виде массива целых чисел. В нашем примере по ширине поле имеет 10 квадратов, и по высоте 20 квадратов (рисунок ниже).
</p>

<img src="./field.jpg" width="350px">

<p>
Подитожим наши знания и рассмотрим исходный код примера (файл MyApp.h).
</p>

<pre>

#define SCALE 30 //размер одного квадрата на игровом поле в пикселях

#define N 10 //ширина игрового поля в квадратах
#define M 20 //высота игрового поля в квадратах

//вычисляем размер окна для игры Тетрис в пикселях
//вычисления необходимы для задания размера
//окна приложения WinAPI функция CreateWindow()
#define WINDOW_WIDTH N * SCALE
#define WINDOW_HEIGHT M * SCALE

//задаем игровое поле Тетриса (размер в квадратах не в пикселях)
int field[M][N] = { 0 };

//массив с описанием всех 7 фигурок Тетрамино
int figures[7][4]=
{
	1,3,5,7, // I
	2,4,5,7, // S
	3,5,4,6, // Z
	3,5,4,7, // T
	2,3,5,7, // L
	3,5,7,6, // J
	2,3,4,5, // O
};

</pre>

<p>
Следущий шаг - привязка Тетрамино к игровому полю. Для этого нужно локальные координаты Тетрамино перевести в координаты игрового поля. На экране отсчет координат начинаеться в верхнем левом углу, как на рис. ниже.
</p>

<p>
Для примера размещения Тетрамино на игровом поле возьмем Z тетрамино (рис.выше). Видно, что квадрат Тетрамино №5 будет иметь координаты (1;2), квадрат №6 будет иметь координаты (0;3) и т.д. 
</p>

<p>
Добавим немного математики - если номер клетки Тетрамино разделить с остатком на 2 получим столбец, колонку если делить 2 нацело. Тогда квадратик Тетрамино №5 будет иметь координаты (1;2) = (5 % 2; 5 / 2). В С++ программировании оператор % — это остаток от деления, а оператор / — частное от деления (деление нацело)
</p>

<img src="./tetramino3.jpg" width="400px">

<p>
Следущий шаг отображение Тетрамино на игровом поле. Для этого создадим структуру Point.
</p>

<pre>

struct Point
{
	int x, y;
} a[4],b[4];

</pre>

<p>
Затем с помощью первого цикла for мы переведем «локальные» координаты каждого отдельного кусочка тетрамино в «глобальные», а затем с помощью второго цикла for отобразим это всё на игровом поле. При этом стоит учитывать, что размеры отдельного квадрата Тетрамино составляют 30×30 пикселей.
</p>

<pre>

void CMyApp::RenderScene()
{
	static bool begin_Game = true;

	//1)создаем тетримино на игровом поле
	//переводим локальные координаты тетрамино
	//в глобальные координаты игрового поля
	//перемення n хранит номер тетрамино
	//в массиве (т.е. какой тетрамино рисовать)
	if(begin_Game)
	{
		begin_Game = false;

		srand((unsigned)time( NULL ));
		n = rand() % 7;

		for (int i = 0; i &lt 4; i++)
		{
			a[i].x = figures[n][i] % 2; 
			a[i].y = figures[n][i] / 2;  
		}
	}

	//2)рисуем тетрамино которое движется вниз используя функцию WinAPI Rectangle()
	for (int i = 0; i < 4; i++)
	{
		hBrush = CreateSolidBrush(RGB(colors[n].r, colors[n].g, colors[n].b));
		hOldBrush = (HBRUSH)SelectObject(hBackBuffer, hBrush);
	
		// Устанавливаем позицию каждого кусочка тетрамино
		Rectangle( hBackBuffer, a[i].x * SCALE, a[i].y * SCALE,
			(a[i].x + 1) * SCALE, (a[i].y + 1) * SCALE );	

		SelectObject(hBackBuffer, hOldBrush);
					DeleteObject(hBrush);
		DeleteObject(hBrush);
	}

</pre>

<p>
На данном этапе мы нарисовали одно тетрамино (см.рисунок ниже).
</p>

<img src="./field2.jpg" width="350px">

<p>
Как устроено вращение одного тетрамино. Тут пригодятся знания линейной алгебры- вращение 2D.
</p>

<pre>

	//вращение вокруг точки с координатами x_0 и y_0
	//вращаем точку с координатами x и y
	//вращение 2D то есть вокруг оси Z
	//результат поворота точки (x,y) вокруг (x_0, y_0) будет храниться в (X,Y)

	X = x_0 + (x − x_0) * cos⁡(a) − (y − y_0 ) * sin⁡(a);
	Y = y_0 + (y − y_0) * cos⁡(a) + (x − x_0 ) * sin⁡(a);

</pre>

<p>
В Тетрисе все повороты фигур идут на 90 градусов. Известно что:
</p>

<pre>

	sin(90 degree) = 1
	cos(90 degree) = 0

</pre>

<p>
Поэтому вышеприведенную формулу поворота вокруг оси Z можно сократить, и она будет выглядеть так:
</p>

<pre>

	X = x_0 − (y − y_0);
	Y = y_0 + (x − x_0);

</pre>

<p>
Вертикальное перемещение тетрамино осуществляется 1 клетка вниз раз в 20 кадров. В игре стоит ограничивающая FPS функция до 30 кадров в секунду. В ускоренном режиме тетрамино движеться 1 клетка вниз за 1 кадр.
</p>

<p>
Сначала в игре рисуется все игровое поле, а после рисуется одно текущее тетрамино которое движется вниз.
</p>

<p>
Данный пример в статье реализован на C++ WinAPI Visual Studio 2019. Оригинал статьи предлагает реализацию на Visual Studio 2015 и при помощи библиотеки SFML.
</p>

<p>
Часть 1 оригинальной статьи находиться здесь <a href="https://ravesli.com/graficheskaya-biblioteka-sfml-sozdanie-tetrisa-chast-1/">Часть №1: Создание игры «Тетрис» на С++/SFML</a>
</p>

<p>
Часть 2 оригинальной статьи находиться здесь <a href="https://ravesli.com/graficheskaya-biblioteka-sfml-sozdanie-tetrisa-chast-2/">Часть №2: Создание игры «Тетрис» на C++/SFML</a>
</p>

<p>
Часть 3 оригинальной статьи находиться здесь <a href="https://ravesli.com/graficheskaya-biblioteka-sfml-sozdanie-tetrisa-chast-3/">Часть №3: Создание игры «Тетрис» на С++/SFML</a>
</p>

</body>
</html>
