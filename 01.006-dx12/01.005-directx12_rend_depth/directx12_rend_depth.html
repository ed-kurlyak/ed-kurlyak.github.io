<!DOCTYPE html>
<html>
<head>
	<title>Программирование DirectX 12 - Рендеринг глубины в текстуру</title>

	<meta name="DESCRIPTION" content="Программирование DirectX 12 - Рендеринг глубины в текстуру">
	<meta name="KEYWORDS" content="Программирование DirectX 12 - Рендеринг глубины в текстуру">

<style type="text/css">
body {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #000;
	color: #ffffff;
}

pre {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #ffffaa;
	color: #000;
	width: max-content;
	min-width: 100%;

}

div.my_selected {
	width: 100%;
	background-color: #ffff55;
	position: relative;
}

a:link, a:visited { color: #aaaaaa; text-decoration: none; font-weight: normal;} 
a:active, a:hover { color: #aaaaaa; text-decoration: underline;}

p {
	text-align: justify;
	margin-right: 20px;
}

</style>	
</head>
<body>

<h3>
Программирование DirectX 12 - Рендеринг глубины в текстуру
</h3>


<img src="./Volume_Fog_TexColors.png" width="600" alt="directx 12 volume fog">

<p>
Исходный код для Visual Studio 2019:
</p>

<a href="./Volume_Fog_TexColors_DX12_1_CmdList.rar">DirectX 12 Рендеринг глубины в текстуру - синхронизация CPU-GPU один CommandList</a>

<br>

<a href="./Volume_Fog_TexColors_DX12_3_CmdList.rar">DirectX 12 Рендеринг глубины в текстуру - синхронизация CPU-GPU три CommandList</a>

<br>

<a href="./Volume_Fog_TexDepth_DX12_1_CmdList.rar">DirectX 12 Рендеринг глубины в буфер глубины - синхронизация CPU-GPU один CommandList</a>

<br>

<a href="./Volume_Fog_TexDepth_DX12_3_CmdList.rar">DirectX 12 Рендеринг глубины в буфер глубины - синхронизация CPU-GPU три CommandList</a>

<p>
Что бы программировать DirectX12 вам необходимо минимум Windows 10.
</p>

<p>
В первом и третьем примере в приложении имеется один CmdList. Мы подаем порцию команд (кадр) от CPU на GPU и после подачи команд CPU ждет GPU когда GPU закончит работу (см.функцию Draw_MeshManager()). После этого CPU подает на GPU следующий кадр.
</p>

<p>
Второй и четверный пример - имеется три CmdList, и приложение постоянно подает кадры от CPU на GPU не дожидаясь окончания работы GPU (хотя есть синхронизация для каждого CmdList). Таким образом GPU постоянно загружено очередью кадров, кадры в GPU посылаются один за другим, не дожидаясь окончания работы GPU как в первом примере.
</p>

<p>
В первых двух примерах значения глубины записываются в обыкновенную текстуру которая установлена как render target.
</p>

<p>
Во вторых двух примерах значения глубины записываются в буфер глубины - это тоже обыкновенная текстура.
</p>

<p>
Во всех примерах на экране появляется объемный туман в виде куба. Есть два вида тумана- туман на всю сцену, и туман в каком то месте сцены т.е. туман заключен в объем. Для этого примера за объем для тумана взята модель куба. Всего приложение имеет три прохода шейдеров. В первом проходе в текстуру (буфер глубины) записываются значения глубины передних полигонов куба (глубина пикселей). Во втором прходе в другую текстуру записываются значения глубины пикселей задних полигонов куба. В третьем проходе мы устанавливаем в шейдер две предыдущие текстуры, в шейдере берем разницу между значениями глубины, и эта разница принимается за интенсивность тумана - пиксель с данной интенсивностью выводится на экран.
</p>

</body>
</html>
