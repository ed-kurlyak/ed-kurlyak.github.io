<html>
<head>
<link href="./../my_style.css" rel="stylesheet" type="text/css" />
</head>


<body>


<div class="my_main2">
<h4 class="my_font3">

Софтварный конвеер рендеринга - минимальные требования


<br>

<br>

Сначала необходимо создать пустой конскольный проект в Visual Studio, затем добавить в проект пустой файл .cpp, и в него скопировать текст примера ниже.

<br>

<br>


В чем заключается главная особенность программирования трехмерной графики- неободимо объемную модель с вершинами xyz, созданную в трехмерном пространстве с осями xyz, отобразить на плоском экране монитора, который можно описать двухмерным пространством xy - высота и ширина экрана.

<br>

<br>

Трехмерная модель может быть создана например в пакете трехмерного моделирования 3DS Max. В данной статье, в программе 3DS Max была создана модель трехмерно куба, модель была сохранена в файл, и затем из этого файла были взяты координаты куба xyz, которые были помещены в массив вершин в коде С++, в данном примере.

<br>

<br>

Пример приведенный ниже, создан в целях демонстрации и наглядности минимальных требований для софтварного конвеера рендеринга, не оптимизирован, и не даст высоких показателей производительности, подает информацию в линейном виде.

<br>

<br>

Все преобразования, которые проходят вершины исходной трехмерной модели до вывода ее на плоский двухмерный экран монитора и называется конвеером рендеринга.

<br>

<br>

Минимальный ковеер рендеринга выглядит так:

<br>
1 - имеется трехмерная модель куба, все 24 вершины куба записаны в массиве в формате xyz;
<br>
2 - модель необходимо разместить на сцене, повернуть, или поменять масштаб модели. для этого каждую вершину трехмерной модели куба xyz умножить на матрицы мира, вида, проекции, т.е. умножить на матрицы трансформации, например матрица поворота по оси Y, матрица перемещения модели на сцене, или матрица мира (т.е. матрица размещения на сцене), фактически необходимо выполнить операцию умножения вектора на матрицу;
<br>
3 - поскольку ширина и высота экрана монитора (или ширина и высота окна приложения) имеют разные значения, мы должны вывести изображение без потерь пропорции; каждую координату x из всех вершин модели необходимо поделить на значение величины пропорций экрана. Пропорции экрана это - ширина экрана поделенная на высоту.
<br>
4 - далее необходимо создать иллюзию перспективы на экране монитора- то есть объекты которые ближе, выглядят больше, объекты которые далшье на сцене- должны выглядеть меньше; каждую вершину модели- значения x и y поделить на значение z этой же вершины.
<br>
5 - теперь над всеми 24 вершинами модели следует произвести преобразование в экранные координаты, в зависимости от разрешения дисплея, можно использовать экранную матрицу; после деления на z в предыдущем пункте, мы получим вершины в диапазоне от 0 до 1, теперь эти знаения вершин от 0 до 1 нужно привести в соответствие к размерам экрана, например 800 на 600 пикселей; т.е. например 0 это 0, а 1 это 800, и 0 это 0 а 1 это 600; в результате мы получим, что вершина со значением х = 0,25 будет равна в экранных координатах 200 пикселей; вершина со значением y = 0,5 будет равна 300 пикселей;
<br>
6 - теперь когда есть экранные координаты модели, используя графические средства- провести линии между рассчитанными 24 точками на экране, в результате мы получим проволочное изображение иходной модели на экране, т.е. каркасную модель куба;

<br>
<br>
<br>

Файл .cpp примера <a href=post1.cpp>Загрузить</a>

<br>
<br>
<br>
<img src=post1.jpg></img>



<br>
<br>
<br>
Код примера на С++.
<br>
<br>



<code>


<br>//подключаем файлы заголовков

<br>
#include &ltwindows.h&gt
<br>
#include &ltmath.h&gt
<br>


<br>//глобальная переменная дескриптор окна приложения
<br>//будет использоватся для создании конетекста устройства
<br>//при рисовании линий каркасной модели куба

<br>
HWND hwnd;
<br>


<br>//структура будет содержать все 24 вершины xyz модели куба

<br>
typedef struct slib_vector3
<br>
{
<br>
	float x,y,z;
<br>
} lib_vector3;
<br>


<br>//структура будет содержать матрицы трансформации

<br>
typedef struct slib_4x4_matrix
<br>
{
<br>
float m[4][4];
<br>
} lib_4x4_matrix;
<br>


<br>//функция умножает каждую вершину модели куба xyz на матрицу 4x4
<br>//фактически в этой функции производится математическая операция
<br>//умножения вектора из трех компонент xyz на матрицу размером 4x4

<br>
lib_vector3 Mat4x4_Vect3_Mul( lib_4x4_matrix mat, lib_vector3 v )
<br>
{
<br>
lib_vector3 temp;
<br>

<br>
temp.x = v.x * mat.m[0][0] + v.y * mat.m[1][0] + v.z * mat.m[2][0] + mat.m[3][0];
<br>
temp.y = v.x * mat.m[0][1] + v.y * mat.m[1][1] + v.z * mat.m[2][1] + mat.m[3][1];
<br>
temp.z = v.x * mat.m[0][2] + v.y * mat.m[1][2] + v.z * mat.m[2][2] + mat.m[3][2];
<br>

<br>
return temp;
<br>
}
<br>


<br>//главная функция приложения, которая производит все вычисления
<br>//и выводит каркасное изображение модели куба на экран в каждом кадре

<br>
void Draw_Cube()
<br>
{
<br>


<br> //куб на экране будет вращатся, вычисляем угол на который модель куба
<br> //будем поворачивать в каждом кадре

<br>
	static float angle = 0.0;
<br>


<br> //в каждом кадре к значению угла поворота добавляем новое значение

<br>
	angle+=(float)(3.1415926/180);
<br>

<br> //если угол поворота болье 360 градусов делаем его равным 0

<br>
    if(angle>3.1415926*2) angle = 0;
<br>


<br> //модель куба содержит 24 вершины

<br>
	UINT nVertCount = 24;
<br>


<br> //для дальнейших преобразований
<br> //заносим в массив все 24 вершины модели куба

<br>
lib_vector3 vert_buff[24] = {-5.000000, 5.000000,-5.000000,
<br>
	5.000000, 5.000000,-5.000000,
<br>
	5.000000, -5.000000,-5.000000,
<br>
	-5.000000, -5.000000,-5.000000,
<br>
	-5.000000, 5.000000, 5.000000,
<br>
	5.000000, 5.000000, 5.000000,
<br>
	5.000000, 5.000000,-5.000000,
<br>
	-5.000000, 5.000000,-5.000000,
<br>
	-5.000000, -5.000000,5.000000,
<br>
	5.000000, -5.000000,5.000000,
<br>
	5.000000, 5.000000, 5.000000,
<br>
	-5.000000, 5.000000, 5.000000,
<br>
	-5.000000, -5.000000,-5.000000,
<br>
	5.000000, -5.000000,-5.000000,
<br>
	5.000000, -5.000000, 5.000000,
<br>
	-5.000000, -5.000000, 5.000000,
<br>
	-5.000000, 5.000000, 5.000000,
<br>
	-5.000000, 5.000000,-5.000000,
<br>
	-5.000000,-5.000000,-5.000000,
<br>
	-5.000000,-5.000000, 5.000000,
<br>
	5.000000, 5.000000,-5.000000,
<br>
	5.000000, 5.000000, 5.000000,
<br>
	5.000000,-5.000000, 5.000000,
<br>
	5.000000,-5.000000,-5.000000};
<br>

<br>

<br> //объявляем матрицу вращения по оси X
<br> //используя значение угла поворота

<br>
	lib_4x4_matrix mWorldRotX={
<br>
    1, 0, 0, 0,
<br>
    0, cos(angle), sin(angle), 0,
<br>
    0,-sin(angle),  cos(angle), 0,
<br>
    0, 0, 0, 1};
<br>


<br> //объявляем матрицу вращения по оси Y
<br> //используя значение угла поворота

<br>
    lib_4x4_matrix mWorldRotY={
<br>
    cos(angle), 0, -sin(angle), 0,
<br>
    0, 1, 0, 0,
<br>
    sin(angle), 0, cos(angle), 0,
<br>
    0, 0, 0, 1};
<br>


<br> //объявляем матрицу вращения по оси Z
<br> //используя значение угла поворота

<br>
    lib_4x4_matrix mWorldRotZ={
<br>
    cos(angle), sin(angle), 0, 0,
<br>
    -sin(angle), cos(angle), 0, 0,
<br>
    0, 0, 1, 0,
<br>
    0, 0, 0, 1};
<br>


<br> //матрица мира, размещает куб на сцене
<br> //на расстоянии 15 единиц в глубину от зрителя

<br>
    lib_4x4_matrix mWorld={
<br>
    1, 0, 0, 0,
<br>
    0, 1, 0, 0,
<br>
    0, 0, 1, 0,
<br>
    0, 0, 15.0, 1};
<br>

<br>
	
<br>

<br>


<br> //получаем размеры окна приложения	

<br>
	RECT rc;
<br>
    GetClientRect(hwnd, &rc);
<br>



	
<br>
	long nViewWidth  = rc.right - rc.left;
<br>
    long nViewHeight = rc.bottom - rc.top;
<br>

<br>
	long nViewX      = rc.left;
<br>
    long nViewY      = rc.top;
<br>

<br>

<br> //вычисляем apect ratio, соотношение ширины окна приложения к его высоте

<br>
	float fAspect = (float) nViewWidth/nViewHeight;
<br>
    
<br>

<br> //подготовительные действия окончены, теперь можно подвергнуть
<br> //вершины куба преобразованиям, в цикле проходим по всем 24 вершинам куба

<br>
	for ( UINT i = 0; i < nVertCount; i++)
<br> {

	
<br> //умножаем каждую вершину модели куба на матрицу вращения по оси X, по оси Y
<br> //и на матрицу мира (матрицу вращения по оси Z не используем, она была
<br> //приведена выше в ознакомительных целях)

<br>
		vert_buff[i] = Mat4x4_Vect3_Mul(mWorldRotX, vert_buff[i]);
<br>
		vert_buff[i] = Mat4x4_Vect3_Mul(mWorldRotY, vert_buff[i]);
<br>
		vert_buff[i] = Mat4x4_Vect3_Mul(mWorld, vert_buff[i]);
<br>
	

<br> //учитываем пропорции экрана, координата x делится
<br> //на значение aspect ratio (соотношение сторон окна приложения)

<br>
		vert_buff[i].x = vert_buff[i].x / fAspect;
<br>
	

<br> //создаем перспективу, объекты которые ближе выглядят больше,
<br> //объекты которые дальше выглядят меньше, то же относится и к
<br> //вершинам и расстоянию между верщинами модели куба

<br>
		vert_buff[i].x = vert_buff[i].x / vert_buff[i].z;
<br>
		vert_buff[i].y = vert_buff[i].y / vert_buff[i].z;
<br>



<br> //для вывода на экран монитора, и в окно приложения,
<br> //координаты модели куба переводим в 2- х мерные экранные координаты,
<br> //которые имеют начало в левом верхнем углу монитора, или в
<br> //левом верхнем углу окна приложения, экранные координаты
<br> //зависят от высоты и ширины окна приложения, фактически центр трехмерной
<br> //координатной системы (находится в центре экрана) в которой размещен куб 
<br> //переносится в левый верхний угол окна приложения (или в левый верхний угол 
<br> //экрана монитора, при полноэкранном выводе на экран), в некоторых примерах можно <br> //встретить матрицу экранных преобразований, которая выполняет аналогичные 
<br> //математические операции, но путем умножения вершин модели на экранную матрицу

<br>
		vert_buff[i].x =   vert_buff[i].x * nViewWidth  / 2 + nViewX + nViewWidth  / 2;
<br>
	    vert_buff[i].y =  -vert_buff[i].y * nViewHeight / 2 + nViewY + nViewHeight / 2;
<br>

}
<br>
<br>


<br> //для соединения вершин модели куба линиями будет использованы
<br> //возможности GDI, подготавливается конекст устройства

<br>
	HDC hDC = ::GetDC( hwnd );
<br>

<br>
	LOGBRUSH logBrush;
<br>
	HBRUSH   hBrush = NULL;
<br>
	logBrush.lbStyle = BS_SOLID;
<br>
	logBrush.lbColor = 0 ;
<br>
	hBrush = ::CreateBrushIndirect( &logBrush );
<br>
	FillRect(hDC,&rc,hBrush);
<br>


<br> //в цикле проходим во всем 6- ти сторонам куба
<br> //соединяя линиями все 4- ре вершины каждой стороны

<br>
	for ( int i = 0; i < 6; i++)
<br>
	{
<br>


<br> //создаем перо средствами GDI

<br>
		HPEN hPen = CreatePen(PS_SOLID, 5, RGB(128, 0, 0));
<br>
		HPEN hOldPen = (HPEN)SelectObject (hDC, hPen);
<br>


<br> //отмечаем начало первой линии

<br>
		MoveToEx(hDC,(int)vert_buff[i * 4].x, (int)vert_buff[i * 4].y,NULL);
<br>


<br> //соединяем линиями все 4- ре точки каждой стороны модели куба        

<br>
		LineTo(hDC,(int)vert_buff[i * 4 + 1].x, (int)vert_buff[i * 4 + 1].y);
<br>
		LineTo(hDC,(int)vert_buff[i * 4 + 2].x, (int)vert_buff[i * 4 + 2].y);
<br>
		LineTo(hDC,(int)vert_buff[i * 4 + 3].x, (int)vert_buff[i * 4 + 3].y);
<br>
		LineTo(hDC,(int)vert_buff[i * 4].x, (int)vert_buff[i * 4].y);
<br>


<br> //возвращаем старое перо в конекст устройства

<br>
		SelectObject(hDC,hOldPen);
<br>
		DeleteObject (hPen) ;
<br>
}
<br>

<br>

<br> //в конце этой функции видим на экране нарисованную каркасную модель куба
<br> //в следующем кадре к углу поворота добавляется новое значение,
<br> //вершины модели куба снова подвергаются преобразованиям и куб
<br> //выводится на экран с новым углом поворота в итоге мы видим
<br> //как каркасная модель куба вращается на экране

<br>
}
<br>

<br>

<br>


<br> //функция main приложения

<br>
int  main (int argc, char* argv[])
<br>
{
<br>


<br> //устанавливаем заголовок в окне приложения название приложения
<br> //находим дескриптор hwnd окна приложения для создания контекста
<br> //вывода графики и рисования линий каркасной модели куба

<br>
	char str[256];
<br>
	SetConsoleTitle("Sowtware rendering engine (no OpenGL/DirectX)");
<br>
	GetConsoleTitle(str, 256);
<br>
	hwnd = FindWindow(NULL, str);
<br>



<br> //создаем цикл обработки сообщений, в этот цикл добавляем
<br> //функцию рисования модели куба, для плавного вращения куба
<br> //ставим паузу 15 милисекунд, после каждой отрисовки
<br> //модели куба, при получении соответствующего сообщения 
<br> //приложение завершает работу

<br>
		MSG         msg ;
<br>
     while (TRUE)
<br>
          {
<br>
          if (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
<br>
               {
<br>
               if (msg.message == WM_QUIT)
<br>
                    break ;
<br>

<br>
			   TranslateMessage (&msg) ;
<br>
               DispatchMessage (&msg) ;
<br>
               }
<br>
          else
<br>
			  {
<br>
               Draw_Cube () ;
<br>
			   Sleep(15);
<br>
			   }
<br>
          }
<br>

<br>

<br>
	return 0;
<br>
}
<br>

<br>



</code>

</h4>
</div>

</body>
</html>