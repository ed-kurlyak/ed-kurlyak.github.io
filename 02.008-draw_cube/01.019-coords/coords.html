<!DOCTYPE html>
<html>
<head>
	<title>Какими бывают координаты вершин</title>

	<meta name="DESCRIPTION" content="Какими бывают координаты вершин">
	<meta name="KEYWORDS" content="Какими бывают координаты вершин">

<style type="text/css">
body {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #000;
	color: #ffffff;
}

pre {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #ffffaa;
	color: #000;
}

div.my_selected {
	width: 100%;
	background-color: #ffff55;
	position: relative;
}

a:link, a:visited { color: #aaaaaa; text-decoration: none; font-weight: normal;} 
a:active, a:hover { color: #aaaaaa; text-decoration: underline;}

p {
	text-align: justify;
	margin-right: 20px;
}


</style>	
</head>
<body>

<h3>
Какими бывают координаты вершин
</h3>

<p>
После моделирования 3D модели в пакете моделирования (например 3DS Max, Maya, Blender и т.п.) координаты модели находятся в локальных координатах. После умножения на матрицу мира (т.е. матрицу вращения, масштабирования, перемещения) координаты модели находятся в мировом пространстве (у всех объектов на сцене есть общий центр в т.ч. камера имеет свою позицию в мировых координатах). После умножения на матрицу вида - координаты модели находятся в видовом пространстве (центр сцены v(0,0,0) там где расположена камера, наблюдатель). После умножения на матрицу проекции мы переходим к 4х размерных векторам, и у нас однородные координаты вершины (homogeneous space). После деления на Z (или как в графических API происходит деление на 4й компонент W) у нас есть NDC координаты (normalized device coordinates) - т.е. каждый компонет x,y,z находится в диапазоне от -1.0 до +1.0. И после преобразования в экранное пространство дисплея у нас есть экранные координаты - которые и выводятся на экран.
</p>

<p>
Любой 3D конвеер рендеринга должен обеспечить проход вершин модели пошагово от локальных координат до экранных координат.
</p>


<p>
Матрица мира меняется когда объект перемещается, вращается, масштабируется.
</p>

<p>
Матрица вида меняется когда камера (наблюдатель) меняет позицию, вращается.
</p>

<p>
Матрица проекции меняется когда окно меняет размеры.
</p>

<p>
Что такое однородные (гомогенные) координаты - homogeneous space? Пусть у нас есть вектор в декартовой системе координат v(x,y,z) который представляет собой одну вершину модели, и есть матрица mxRes, которая равна произведению матрицы Мира, Вида, Проекции. Тепреь нам нужно перейти от декартовых к однородным координатам, выполнить перспективное деление, и тем самым вернутся обратно к декартовым координатам.
</p>

<pre>

	v(x,y,z)

	mxRes = mxWorld * mxView * mxProjection
	
</pre>

<p>
Теперь согласно ковееру рендеринга вектор v нужно умножить на матрицу mxRes. Матрица проекции расчитывается так что четвертый элемент w равен третьему элементу z. Матрица проекции согласно документации DirectX выглядит так:
</p>

<pre>

	typedef float matrix4x4[4][4];

	float fFov = 3.14f/2.0f; // FOV 90 degree
	float fAspect = 640.0f/480.0f;
	float fZFar = 100.0f;
	float fZNear = 1.0f;

	float    h, w, Q;
	w = (float)(1/tan(fFov*0.5f))/fAspect;
	h = (float)1/tan(fFov*0.5f);
	Q = fZFar/(fZFar - fZNear);

   	matrix4x4 mProj={
	w, 0, 0, 0,
	0, h, 0, 0,
	0, 0, Q, 1,
	0, 0, -Q*fZNear, 0 };
	
</pre>

<p>
Как умножить вектор 3х1 на матрицу 4х4? Необходимо ввести четвертый элемент вектора w = 1: 	v(x,y,z,1) или v(x,y,z,w). Теперь вектор 4х1 мы можем умножить на матрицу 4х4 по правилам умножения.
</p>

<p>
После умножения вектора v(x,y,z,1) на матрицу проекции, мы получаем четвертый элемент вектора w = z - это и есть однородная координата, когда мы трехмерный вектор переводим в четырехмерный, условие w не равно 1. Этот четырехмерный ветор и есть однородная координата. После умножения вектора v на матрицу проекции мы выполняем перспективное деление, т.е. деление на z - и этим мы производим переход от однородного пространства обратно к декартовой системе координат.
</p>

<p>
Так же следует уточнить - в Евклидовой геометрии x,y,z - это обычные координаты точки в 3D пространстве. Но в Проективной геометрии x,y,z носит название однородных координат, так как для проекции 3D на 2D плоскость осуществляется деление на z. В трехмерной графике понятие однородных координат расширили, ввели четвертую компоненту w - теперь с помощью этой компоненты мы можем создавать матрицы 4х4 которые удобны для всех трансформаций сразу. Матрица 3х3 может включать в себя только вращение и масштабирование. Что бы добавить компоненту перемещения- необходимой перейти к матрицам 4х4, что и позволяет сделать четвертая компонента w вектора в трехмерной графике. То есть четвертая компонента w в трехмерной графике - это просто расширение трехмерной графики, все четыре компоненты x,y,z,w в трехмерной графике называются однородными координатами. Но в оригинале в Проективной геометрии- однородными координатами считают x,y,z. В проективной геометрии происходит деление x/z и y/z а в трехмерной графике происходит деление x/w, y/w, z/w.
</p>

<p>
После умножения на матрицу Проекции - четвертая компонента w по сути содержит глубину Z (см. саму матрицу проекции), и мы x делим на w, y делим на w и z делим на w. Это понятно что x,y делиться на глубину w. Но зачем z делить на w? Деление z/w используется в графических API DirectX/OpenGL для того что бы глубина находилась в диапазоне от 0 до 1 с учетом ближней ZNear и дальней ZFar плоскостей отсечения- это условие необходимо для работы Z буфера.
</p>

<p>
В результате перспективного деления мы получаем x,y координаты вектора v готовые для перевода в экранные координаты (экранное пространство). И получаем z координату в диапазоне от 0 до 1.0 готовую что бы ее занести в буфер глубины.
</p>

<p>
В примера в рамках данного изложения гомогенные координаты не используются. В большинстве примеров используется упрощенная матрица проекции, и после умножения на эту матрицу сразу выполняется деление на z:	
</p>

<pre>

   	matrix4x4 mProj={
	w, 0, 0, 0,
	0, h, 0, 0,
	0, 0, 1, 0,
	0, 0, 0, 1 };

	
</pre>

<p>
Но в реальных конвеерах рендеринга DirectX/OpenGL гомогенные координаты использутся, так же используется буфер глубины со значениями от 0 до 1.0.	
</p>

<p>
Почему после деления на z (перспективное деление) координаты x и y должны быть в диапазоне от 0 до 1? Потому что так необходимо для дальнейшего преобразования x и y в экранные координаты. Рассмотрим пример, пусть по ширине x экран имеет разрешение 640 пикселей:
</p>

<pre>

	//случай 1 x &lt z
	z = 4
	x = 2

	//перспективное деление
	x = x / z = 2 / 4 = 0.5

	//экранные координаты в пределах от 0 до 640 по x
	x = x * 640 / 2 + 640/2 = 0.5 * 640/2 + 640/2 = 480

	//случай 2 x &gt z
	z = 4
	x = 8 

	//перспективное деление 
	x = x / z = 8 / 2 = 2.0

	//экранные координаты в пределах от 0 до 640 по x
	x = x * 640 / 2 + 640/2 = 2 * 640/2 + 640/2 = 960  

</pre>

<p>
Видим что в первом случае мы получили корректное значение экранных координат- 480 лежит в диапазоне от 0 до 640. Во втором случае где x больше z мы получили некорректное значение экранных координат - 960 лежит вне диапазона от 0 до 640. Вывод- после перспективного деления мы должны получить x и y в диапазоне от 0 до 1 для корректного преобразования в экранные координаты.
</p>

<p>
Таким образом гомогенные координаты получаем после умножения на матрицу проекции. Так же есть NDC Normalized Device Coordinates - Нормализованные координаты устроства - они получаются после деления x и y на z, то есть мы получаем значения от 0 до 1, после перспективного деления, это и есть NDC, которые теперь можно преобразовать в экранные координаты.
</p>

<p>
Подитожим сказанное.
</p>

<ul>
<li>Локальные координаты модели, после создания модели в пакете 3D моделирования (3DS Max, Maya и т.д.)

<li>Мировые координаты - после умножения на матрицу мира (матрицу вращения, перемещения, масштабирования)

<li>Видовые координаты - после умножения на матрицу вида (камера, наблюдатель)

<li>Гомогенные координаты - после умножения на матрицу проекции (в графических API DirectX, OpenGL)

<li>NDC координаты - Normalized Device Coordinates - после деления на Z т.е. x = x/z и y = y/z

<li>Экранные координаты - после умножения на экранную матрицу, или преобразования в экранные координаты без помощи экранной матрицы	
</ul>

</body>
</html>