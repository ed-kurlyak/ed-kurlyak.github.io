<!DOCTYPE html>
<html>
<head>
	<title>Програмный конвеер рендеринга</title>

	<meta name="DESCRIPTION" content="Програмный конвеер рендеринга">
	<meta name="KEYWORDS" content="Програмный конвеер рендеринга">

<style type="text/css">
body {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #000;
	color: #ffffff;
}

pre {
	font-size: 24px;
	font-family: "Consolas";
	background-color: #ffffaa;
	color: #000;
	width: max-content;
	min-width: 100%;
}

div.my_selected {
	width: 100%;
	background-color: #ffff55;
	position: relative;
}

a:link, a:visited { color: #aaaaaa; text-decoration: none; font-weight: normal;} 
a:active, a:hover { color: #aaaaaa; text-decoration: underline;}

p {
	text-align: justify;
	margin-right: 20px;
}


</style>	
</head>
<body>

<p>
Добавим Экранную матрицу.
</p>

<p>
Загрузить архив с примерами <a href="../source.rar">ЗДЕСЬ</a>.
</p>


<p>
Что делает экранная матрица. Если раньше мы писали такой код:
</p>

<pre>

	for ( int i = 0; i &lt 8; i++ )
	{
		matrix4x4 m = Mat4x4_Mat4x4_Mul(mxRotateX, mxRotateY);
		vertex v = Vec3_Mat4x4_Mul(vert_buff[i], m);

		v.z = v.z + 15.0f;
		v.x = v.x / v.z;
		v.y = v.y / v.z;
		v.x = v.x / ((float)rc.right / (float)rc.bottom);

		//обратите внимание на этот момент
		//преобразование в экранные координаты
		v.x = v.x * rc.right / 2.0f + rc.right / 2.0f;
		v.y =-v.y * rc.bottom / 2.0f + rc.bottom / 2.0f;

		vert_buff_res[i] = v;
	}

</pre>

<p>
То теперь мы его заменили на такой код преобразования в экранные координаты:	
</p>


<pre>

	float alpha = (0.5f*m_nViewWidth);
	float beta  = (0.5f*m_nViewHeight);
	
	matrix4x4 mScreen = {
		alpha,  0,      0,    0, 
		0,      -beta,  0,    0, 
		0,	0,	1,    0,
		alpha,  beta,	0,    1};


	for (UINT i = 0; i < m_nVertCount; i++)
	{
		vector3 v;

		matrix4x4 t;

		t = Mat4x4_Mat4x4_Mul(mxRotateX, mxRotateY);
		t = Mat4x4_Mat4x4_Mul(t, mxRotateZ);
		t = Mat4x4_Mat4x4_Mul(t, mWorld);
		t = Mat4x4_Mat4x4_Mul(t, mView);
		t = Mat4x4_Mat4x4_Mul(t, mProj);

		v = Vec3_Mat4x4_Mul(t, m_vert_buff[i]);

		v.x = v.x / v.z;
		v.y = v.y / v.z;

		//преобразование в экранные координаты
		//умножение вершины на экранную матрицу
		v = Vec3_Mat4x4_Mul(mScreen, v);

		m_vert_buff_transformed[i] = v;
	}
	
</pre>

<p>
Как видите все как раньше- умножение вершин на матрицы, деление на Z, а потом умножение на экранную матрицу, вместо преобразования в экранные координаты.	
</p>

Загрузить проект /src/01.012-mx_screen/Cube_RotateY_mxScreen.

</body>
</html>
